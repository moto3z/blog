<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>20230823 구름톤2주차수요일 | blog</title>
<meta name="keywords" content="">
<meta name="description" content="구름톤 2주차 PS 2주차에서 가장 인상깊었던 문제는 백준에서의 1605문제 ( https://www.acmicpc.net/problem/1605 ) 랑 비슷한 유형의 문제였는데 유형이 비슷할뿐이지 핀트가 약간 달라 문제를 설명하면 아래와 같았습니다 1) 오리진 문자열 &#34;abcd&#34; 가 있습니다 2) 오리진 문자열을 3개의 구간으로 쪼개는 모든 경우의 수는 아래처럼 총 3가지 입니다 a/b/cd a/bc/d ab/c/d 3) 쪼갠 문자열을 중복을 제거하고 사전순으로 정렬하면 아래처럼 6개의 원소를 갖게 됩니다. a ab b bc cd c 4) 위 원소들의 인덱스를 구하는게 문제였습니다 문제를 읽고 나니 솔직히 처음에는 단순히 구현문제인줄 알았습니다.">
<meta name="author" content="">
<link rel="canonical" href="https://moto6.github.io/blog/posts/20230823-%EA%B5%AC%EB%A6%84%ED%86%A42%EC%A3%BC%EC%B0%A8%EC%88%98%EC%9A%94%EC%9D%BC/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://moto6.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://moto6.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://moto6.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://moto6.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://moto6.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="20230823 구름톤2주차수요일" />
<meta property="og:description" content="구름톤 2주차 PS 2주차에서 가장 인상깊었던 문제는 백준에서의 1605문제 ( https://www.acmicpc.net/problem/1605 ) 랑 비슷한 유형의 문제였는데 유형이 비슷할뿐이지 핀트가 약간 달라 문제를 설명하면 아래와 같았습니다 1) 오리진 문자열 &#34;abcd&#34; 가 있습니다 2) 오리진 문자열을 3개의 구간으로 쪼개는 모든 경우의 수는 아래처럼 총 3가지 입니다 a/b/cd a/bc/d ab/c/d 3) 쪼갠 문자열을 중복을 제거하고 사전순으로 정렬하면 아래처럼 6개의 원소를 갖게 됩니다. a ab b bc cd c 4) 위 원소들의 인덱스를 구하는게 문제였습니다 문제를 읽고 나니 솔직히 처음에는 단순히 구현문제인줄 알았습니다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://moto6.github.io/blog/posts/20230823-%EA%B5%AC%EB%A6%84%ED%86%A42%EC%A3%BC%EC%B0%A8%EC%88%98%EC%9A%94%EC%9D%BC/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-23T22:16:09+09:00" />
<meta property="article:modified_time" content="2023-08-23T22:16:09+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="20230823 구름톤2주차수요일"/>
<meta name="twitter:description" content="구름톤 2주차 PS 2주차에서 가장 인상깊었던 문제는 백준에서의 1605문제 ( https://www.acmicpc.net/problem/1605 ) 랑 비슷한 유형의 문제였는데 유형이 비슷할뿐이지 핀트가 약간 달라 문제를 설명하면 아래와 같았습니다 1) 오리진 문자열 &#34;abcd&#34; 가 있습니다 2) 오리진 문자열을 3개의 구간으로 쪼개는 모든 경우의 수는 아래처럼 총 3가지 입니다 a/b/cd a/bc/d ab/c/d 3) 쪼갠 문자열을 중복을 제거하고 사전순으로 정렬하면 아래처럼 6개의 원소를 갖게 됩니다. a ab b bc cd c 4) 위 원소들의 인덱스를 구하는게 문제였습니다 문제를 읽고 나니 솔직히 처음에는 단순히 구현문제인줄 알았습니다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://moto6.github.io/blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "20230823 구름톤2주차수요일",
      "item": "https://moto6.github.io/blog/posts/20230823-%EA%B5%AC%EB%A6%84%ED%86%A42%EC%A3%BC%EC%B0%A8%EC%88%98%EC%9A%94%EC%9D%BC/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "20230823 구름톤2주차수요일",
  "name": "20230823 구름톤2주차수요일",
  "description": "구름톤 2주차 PS 2주차에서 가장 인상깊었던 문제는 백준에서의 1605문제 ( https://www.acmicpc.net/problem/1605 ) 랑 비슷한 유형의 문제였는데 유형이 비슷할뿐이지 핀트가 약간 달라 문제를 설명하면 아래와 같았습니다 1) 오리진 문자열 \u0026#34;abcd\u0026#34; 가 있습니다 2) 오리진 문자열을 3개의 구간으로 쪼개는 모든 경우의 수는 아래처럼 총 3가지 입니다 a/b/cd a/bc/d ab/c/d 3) 쪼갠 문자열을 중복을 제거하고 사전순으로 정렬하면 아래처럼 6개의 원소를 갖게 됩니다. a ab b bc cd c 4) 위 원소들의 인덱스를 구하는게 문제였습니다 문제를 읽고 나니 솔직히 처음에는 단순히 구현문제인줄 알았습니다.",
  "keywords": [
    
  ],
  "articleBody": "구름톤 2주차 PS 2주차에서 가장 인상깊었던 문제는 백준에서의 1605문제 ( https://www.acmicpc.net/problem/1605 ) 랑 비슷한 유형의 문제였는데 유형이 비슷할뿐이지 핀트가 약간 달라 문제를 설명하면 아래와 같았습니다 1) 오리진 문자열 \"abcd\" 가 있습니다 2) 오리진 문자열을 3개의 구간으로 쪼개는 모든 경우의 수는 아래처럼 총 3가지 입니다 a/b/cd a/bc/d ab/c/d 3) 쪼갠 문자열을 중복을 제거하고 사전순으로 정렬하면 아래처럼 6개의 원소를 갖게 됩니다. a ab b bc cd c 4) 위 원소들의 인덱스를 구하는게 문제였습니다 문제를 읽고 나니 솔직히 처음에는 단순히 구현문제인줄 알았습니다. n 제한도 300이라 단순한 부르트포스가 가능하다고 판단하였고, 메인루프에서 n * (n-1) 가지 경우에 대해서 탐색을 허용한다면 브루트포스이고 이 문제의 최대 길이가 300 이기 때문에 최악의 경우 9만건정도만 계산한다면 답을 구할수 있다는 판단하에 구현을 시작했습니다. 그냥 시키는데로 구현을 하고 코드를 제출했는데, 전체 20개중 5개정도의 TC 에서 Fail 이 발생하였습니다. 그리고 여기서부터 대삽질이 시작되는데요 삽질의 시작 흠.. 어디보자.. 성능이 구려질만한곳이 있나.. 해서 성능개선 코드를 적용하였고 TC 에서 Fail 이 하나 줄어들었습니다 하지만 여전이 4개의 TC 가 빨간 에러를 뿜뿜하고 있었고 저는 “아 이거 JVM 억까가 심하네” 라는 잘못된 생각을 했고 아무런 근거도 없는 이 잘못된 생각이 대삽질의 발단이 되었습니다. JVM 언어가 문제니까 요즘 회사에서 스터디도 하면서 재미나게 배우고 있는 Go Lang 으로 코테문제를 박살내주겠어! 하는 생각으로, 코틀린으로 작성한 코드를 고랭으로 마이그레이션을 하기 시작했습니다. readLine()!!.toInt() val inputString = readLine()!! val pointMapper: Map = getPointMapper(inputString); var maxi = -1; for (first in 1 until stringSize) { for (second in first + 1 until stringSize) { val section1: String = inputString.substring(0, first) val section2: String = inputString.substring(first, second) val section3: String = inputString.substring(second, stringSize) maxi = Math.max( pointMapper[section1]!! + pointMapper[section2]!! + pointMapper[section3]!!, maxi ) } } 이랫던 코틀린 메인코드를\nvar n int fmt.Scan(\u0026n) var inputString string fmt.Scan(\u0026inputString) pointMapper := getPointMapper(inputString) maxi := -1 stringSize := len(inputString) for first := 1; first \u003c stringSize; first++ { for second := first + 1; second \u003c stringSize; second++ { section1 := inputString[0:first] section2 := inputString[first:second] section3 := inputString[second:stringSize] maxi = max(pointMapper[section1] + pointMapper[section2] + pointMapper[section3], maxi) } } 이렇게 고랭으로 변환했습니다\n그렇게 고랭으로 변환해서 제출하니 아니 똑같은 TC 에서 Fail 이 발생하였습니다. 지나고 나니 이쯤에서 “언어는 문제가 아니야 알고리즘이 문제야!” 라는 생각을 했어야 했습니다. 하지만 “코끼리를 생각하지마” 하면 코끼리만 생각하는게 인간인지라 아 이게 역시 “메모리를 관리해주는 매니지드 언어의 한계구나 ㅋㅋ C++로 짜야겠어” 라는 뇌절 2탄을 찍으며 또 열심히 C++로 또 다시 마이그레이션을 했습니다. 근데 C++은 코로나 전, 삼성코테 준비할때나 쓰던거라 기억도 가물가물하고 이쯤 되니 벌써 새벽 2시에 근접한 시간이라 그냥 포기하고 잠들었습니다. 그렇게 자고 일어나서, 제한시간의 90%가 흘러 마감까지 4시간 남았을때 포기할까 하다가 아침에 눈도 빨리 떠지고 해서 출근전 회사 앞 카페에서 문제를 풀고 가기로 했습니다. 출근길 전철에서 전날 풀다가 포기한 문제들과 제 코드를 보다 보니 여기저기 의심스러운 부분들이 보이기 시작했습니다. MainLoop 의 시간복잡도만 생각할께 아니라, 부분문자열을 구하거나, 인덱스를 구하는 부분에서의 시간복잡도도 의심이 들기 시작했고, 출근하기 전 회사 앞 카페에서 진짜 문제를 발견하게 됩니다. 시간복잡도에 문제가 있는 코드 fun getSubStringRecursive( beginIndex: Int, inputString: String, subStrings: MutableSet ) { if (beginIndex \u003e inputString.length) { return } for (step in 1 until inputString.length - 1) { if ((beginIndex + step) \u003e inputString.length) { return } subStrings.add(inputString.substring(beginIndex, beginIndex + step)) getSubStringRecursive(beginIndex + step, inputString, subStrings) } } 먼저 시간복잡도에 문제가 발생한 부분입니다. 재귀함수를 돌려 모든 부분문자열을 탐색하는데, 이 코드는 너무 비효율적이라는 문제가 있었습니다. 비효율적인 원인은 아래와 같습니다. 결론적으로 위 재귀코드로 부분문자열을 구하면 빅오표현법으로, 2^n 으로, n이 27만 넘어가도 탐색대상이 1억이 넘어가는 현실적으로 사용이 어려운 알고리즘이였습니다. 시간복잡도 문제를 해결한 코드 위 코드의 비효율성을 해결하고자 탐색방식을 오리진 문자열의 인덱스 별로 모두 탐색 » 부분 문자열 길이 기준으로 탐색 을 변경한 코드로 변경했습니다. 변경한 코드도 n^2 의 시간복잡도를 갖지만 n 제한이 300 이라 최대 9만번 루프를 도는데는 문제가 없었습니다. (just for 모든 부분문자열 구하는 로직) fun getSubStringV2(beginIndex22: Int, inputString: String, subStrings: MutableSet) { for (length in 1 until inputString.length - 1) { for (startPoint in inputString.indices) { if ((startPoint + length) \u003e inputString.length) { continue } subStrings.add(inputString.substring(startPoint, startPoint + length)) } } } 그리고.. 출근시간 20분 전에 아슬아슬하게 모든 TC 를 통과하고 기분좋게 출근할수 있었습니다. 교훈 근거도 없이 JVM 언어라서 문제다! 라고 덮어놓고 생각한게 실책인거같습니다. 처음 잘못된 판단을 하고 이를 풀어내는 과정에서 충분히 “그 원인이 아니다” 라는 실마리는 충분히 주어졌지만, 확증편향효과로 인해 캐치하지 못했습니다 무의식적으로 대부분의 경우에, 특히나 쉬운 PS 를 할때는 아래의 논리구조로 문제를 해결하는거같습니다 이슈or증상 \u003e\u003e 가설 \u003e\u003e 시도 \u0026 재시도 \u003e\u003e 운좋으면 해결 / 운나쁘면 삽질 그런데, 생각해보면 꽤나 마구잡이식입니다. 컴퓨터를 만든 선생님께서도 “고장난 시계도 하루에 두번은 맞는다” 라고 하셨더랬죠.. 그래서 앞으로는 아래의 순서로 이슈에 접근하는 노력을 해보려고 합니다 이슈or증상 \u003e\u003e 원인분석 \u003e\u003e 근거확보 \u003e\u003e 문제해결 네.. 그렇습니다 그래도 뭐 풀었으니까요… 이만 줄이겠습니다 ",
  "wordCount" : "732",
  "inLanguage": "en",
  "datePublished": "2023-08-23T22:16:09+09:00",
  "dateModified": "2023-08-23T22:16:09+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://moto6.github.io/blog/posts/20230823-%EA%B5%AC%EB%A6%84%ED%86%A42%EC%A3%BC%EC%B0%A8%EC%88%98%EC%9A%94%EC%9D%BC/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://moto6.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://moto6.github.io/blog" accesskey="h" title="blog (Alt + H)">blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      20230823 구름톤2주차수요일
    </h1>
    <div class="post-meta"><span title='2023-08-23 22:16:09 +0900 KST'>August 23, 2023</span>

</div>
  </header> 
  <div class="post-content"><h2 id="구름톤-2주차-ps">구름톤 2주차 PS<a hidden class="anchor" aria-hidden="true" href="#구름톤-2주차-ps">#</a></h2>
<ul>
<li>2주차에서 가장 인상깊었던 문제는 백준에서의 1605문제 ( <a href="https://www.acmicpc.net/problem/1605">https://www.acmicpc.net/problem/1605</a> ) 랑 비슷한 유형의 문제였는데</li>
<li>유형이 비슷할뿐이지 핀트가 약간 달라 문제를 설명하면 아래와 같았습니다</li>
</ul>
<pre tabindex="0"><code>1) 오리진 문자열 &#34;abcd&#34; 가 있습니다
2) 오리진 문자열을 3개의 구간으로 쪼개는 모든 경우의 수는 아래처럼 총 3가지 입니다
a/b/cd
a/bc/d
ab/c/d
3) 쪼갠 문자열을 중복을 제거하고 사전순으로 정렬하면 아래처럼 6개의 원소를 갖게 됩니다.
a 
ab
b
bc
cd
c
4) 위 원소들의 인덱스를 구하는게 문제였습니다
</code></pre><ul>
<li>문제를 읽고 나니 솔직히 처음에는 단순히 구현문제인줄 알았습니다.</li>
<li>n 제한도 300이라  단순한 부르트포스가 가능하다고 판단하였고, 메인루프에서  n * (n-1) 가지 경우에 대해서 탐색을 허용한다면 브루트포스이고 이 문제의 최대 길이가 300 이기 때문에 최악의 경우 9만건정도만 계산한다면 답을 구할수 있다는 판단하에 구현을 시작했습니다.</li>
<li>그냥 시키는데로 구현을 하고 코드를 제출했는데, 전체 20개중 5개정도의 TC 에서 Fail 이 발생하였습니다. 그리고 여기서부터 대삽질이 시작되는데요</li>
</ul>
<h2 id="삽질의-시작">삽질의 시작<a hidden class="anchor" aria-hidden="true" href="#삽질의-시작">#</a></h2>
<ul>
<li>흠.. 어디보자.. 성능이 구려질만한곳이 있나..  해서 성능개선 코드를 적용하였고 TC 에서 Fail 이 하나 줄어들었습니다</li>
<li>하지만 여전이 4개의 TC 가 빨간 에러를 뿜뿜하고 있었고 저는 &ldquo;아 이거 JVM 억까가 심하네&rdquo; 라는 잘못된 생각을 했고 아무런 근거도 없는 이 잘못된 생각이 대삽질의 발단이 되었습니다.</li>
<li>JVM 언어가 문제니까 요즘 회사에서 스터디도 하면서 재미나게 배우고 있는 Go Lang 으로 코테문제를 박살내주겠어! 하는 생각으로, 코틀린으로 작성한 코드를 고랭으로 마이그레이션을 하기 시작했습니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span>readLine()<span style="color:#f92672">!!</span>.toInt()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> inputString = readLine()<span style="color:#f92672">!!</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">val</span> pointMapper: Map&lt;String, Int&gt; = getPointMapper(inputString);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> maxi = -<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (first <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span> until stringSize) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (second <span style="color:#66d9ef">in</span> first + <span style="color:#ae81ff">1</span> until stringSize) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> section1: String = inputString.substring(<span style="color:#ae81ff">0</span>, first)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> section2: String = inputString.substring(first, second)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> section3: String = inputString.substring(second, stringSize)
</span></span><span style="display:flex;"><span>        maxi = <span style="color:#a6e22e">Math</span>.max(
</span></span><span style="display:flex;"><span>            pointMapper[section1]<span style="color:#f92672">!!</span> + pointMapper[section2]<span style="color:#f92672">!!</span> + pointMapper[section3]<span style="color:#f92672">!!</span>,
</span></span><span style="display:flex;"><span>            maxi
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>이랫던 코틀린 메인코드를</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Scan</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">inputString</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Scan</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">inputString</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pointMapper</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getPointMapper</span>(<span style="color:#a6e22e">inputString</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">maxi</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">stringSize</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">inputString</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">first</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">first</span> &lt; <span style="color:#a6e22e">stringSize</span>; <span style="color:#a6e22e">first</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">second</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">first</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">second</span> &lt; <span style="color:#a6e22e">stringSize</span>; <span style="color:#a6e22e">second</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">section1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">inputString</span>[<span style="color:#ae81ff">0</span>:<span style="color:#a6e22e">first</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">section2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">inputString</span>[<span style="color:#a6e22e">first</span>:<span style="color:#a6e22e">second</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">section3</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">inputString</span>[<span style="color:#a6e22e">second</span>:<span style="color:#a6e22e">stringSize</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">maxi</span> = <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">pointMapper</span>[<span style="color:#a6e22e">section1</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">pointMapper</span>[<span style="color:#a6e22e">section2</span>] <span style="color:#f92672">+</span> <span style="color:#a6e22e">pointMapper</span>[<span style="color:#a6e22e">section3</span>], <span style="color:#a6e22e">maxi</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>이렇게 고랭으로 변환했습니다</p>
</blockquote>
<ul>
<li>그렇게 고랭으로 변환해서 제출하니 아니 똑같은 TC 에서 Fail 이 발생하였습니다.</li>
<li>지나고 나니 이쯤에서 &ldquo;언어는 문제가 아니야 알고리즘이 문제야!&rdquo; 라는 생각을 했어야 했습니다.</li>
<li>하지만 &ldquo;코끼리를 생각하지마&rdquo; 하면 코끼리만 생각하는게 인간인지라</li>
<li>아 이게 역시 &ldquo;메모리를 관리해주는 매니지드 언어의 한계구나 ㅋㅋ C++로 짜야겠어&rdquo; 라는 뇌절 2탄을 찍으며 또 열심히 C++로 또 다시 마이그레이션을 했습니다.</li>
<li>근데 C++은 코로나 전, 삼성코테 준비할때나 쓰던거라 기억도  가물가물하고 이쯤 되니 벌써 새벽 2시에 근접한 시간이라 그냥 포기하고 잠들었습니다.</li>
</ul>
<h2 id="그렇게-자고-일어나서-제한시간의-90가-흘러-마감까지-4시간-남았을때">그렇게 자고 일어나서, 제한시간의 90%가 흘러 마감까지 4시간 남았을때<a hidden class="anchor" aria-hidden="true" href="#그렇게-자고-일어나서-제한시간의-90가-흘러-마감까지-4시간-남았을때">#</a></h2>
<ul>
<li>포기할까 하다가 아침에 눈도 빨리 떠지고 해서 출근전 회사 앞 카페에서 문제를 풀고 가기로 했습니다.</li>
<li>출근길 전철에서 전날 풀다가 포기한 문제들과 제 코드를 보다 보니 여기저기 의심스러운 부분들이 보이기 시작했습니다.</li>
<li>MainLoop 의 시간복잡도만 생각할께 아니라, 부분문자열을 구하거나, 인덱스를 구하는 부분에서의 시간복잡도도 의심이 들기 시작했고, 출근하기 전 회사 앞 카페에서 진짜 문제를 발견하게 됩니다.</li>
</ul>
<h2 id="시간복잡도에-문제가-있는-코드">시간복잡도에 문제가 있는 코드<a hidden class="anchor" aria-hidden="true" href="#시간복잡도에-문제가-있는-코드">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">getSubStringRecursive</span>(
</span></span><span style="display:flex;"><span>    beginIndex: Int,
</span></span><span style="display:flex;"><span>    inputString: String,
</span></span><span style="display:flex;"><span>    subStrings: MutableSet&lt;String&gt;
</span></span><span style="display:flex;"><span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (beginIndex &gt; inputString.length) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (step <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span> until inputString.length - <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((beginIndex + step) &gt; inputString.length) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        subStrings.add(inputString.substring(beginIndex, beginIndex + step))
</span></span><span style="display:flex;"><span>        getSubStringRecursive(beginIndex + step, inputString, subStrings)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>먼저 시간복잡도에 문제가 발생한 부분입니다. 재귀함수를 돌려 모든 부분문자열을 탐색하는데, 이 코드는 너무 비효율적이라는 문제가 있었습니다.</li>
<li>비효율적인 원인은 아래와 같습니다.</li>
</ul>
<p><img loading="lazy" src="../img/20230823-%ec%9e%ac%ea%b7%80.jpg" alt="재귀의치명적임"  />
</p>
<ul>
<li>결론적으로 위 재귀코드로 부분문자열을 구하면 빅오표현법으로, 2^n 으로, n이 27만 넘어가도 탐색대상이 1억이 넘어가는 현실적으로 사용이 어려운 알고리즘이였습니다.</li>
</ul>
<h2 id="시간복잡도-문제를-해결한-코드">시간복잡도 문제를 해결한 코드<a hidden class="anchor" aria-hidden="true" href="#시간복잡도-문제를-해결한-코드">#</a></h2>
<ul>
<li>위 코드의 비효율성을 해결하고자 탐색방식을 <code>오리진 문자열의 인덱스 별로 모두 탐색</code> &raquo; <code>부분 문자열 길이 기준으로 탐색</code> 을 변경한 코드로 변경했습니다.</li>
<li>변경한 코드도 n^2 의 시간복잡도를 갖지만 n 제한이 300 이라 최대 9만번 루프를 도는데는 문제가 없었습니다. (just for 모든 부분문자열 구하는 로직)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">getSubStringV2</span>(beginIndex22: Int, inputString: String, subStrings: MutableSet&lt;String&gt;) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (length <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span> until inputString.length - <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (startPoint <span style="color:#66d9ef">in</span> inputString.indices) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ((startPoint + length) &gt; inputString.length) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            subStrings.add(inputString.substring(startPoint, startPoint + length))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>그리고.. 출근시간 20분 전에 아슬아슬하게 모든 TC 를 통과하고 기분좋게 출근할수 있었습니다.</li>
</ul>
<h2 id="교훈">교훈<a hidden class="anchor" aria-hidden="true" href="#교훈">#</a></h2>
<ul>
<li>근거도 없이 JVM 언어라서 문제다! 라고 덮어놓고 생각한게 실책인거같습니다.</li>
<li>처음 잘못된 판단을 하고 이를 풀어내는 과정에서 충분히 &ldquo;그 원인이 아니다&rdquo; 라는 실마리는 충분히 주어졌지만, 확증편향효과로 인해 캐치하지 못했습니다</li>
<li>무의식적으로 대부분의 경우에, 특히나 쉬운 PS 를 할때는 아래의 논리구조로 문제를 해결하는거같습니다
<pre tabindex="0"><code>이슈or증상 &gt;&gt; 가설 &gt;&gt; 시도 &amp; 재시도 &gt;&gt; 운좋으면 해결 / 운나쁘면 삽질
</code></pre></li>
<li>그런데, 생각해보면 꽤나 마구잡이식입니다. 컴퓨터를 만든 선생님께서도 &ldquo;고장난 시계도 하루에 두번은 맞는다&rdquo; 라고 하셨더랬죠..</li>
<li>그래서 앞으로는 아래의 순서로 이슈에 접근하는 노력을 해보려고 합니다
<pre tabindex="0"><code>이슈or증상 &gt;&gt; 원인분석 &gt;&gt; 근거확보 &gt;&gt; 문제해결 
</code></pre></li>
<li>네.. 그렇습니다 그래도 뭐 풀었으니까요&hellip; 이만 줄이겠습니다</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://moto6.github.io/blog">blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
